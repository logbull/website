---
title: Go Integration - Log Bull Documentation
description: Learn how to integrate Log Bull with Go applications using slog, zap, or logrus. Multiple integration options for Go logging.
---

# Go

LogBull Go library provides multiple integration options for sending logs to your LogBull server.

**GitHub Repository:** [logbull-go](https://github.com/logbull/logbull-go)

## Installation

```bash
go get github.com/logbull/logbull-go
```

## Quick start

The fastest way to start using LogBull is with the standalone logger:

```go
package main

import (
    "github.com/logbull/logbull-go/logbull"
)

func main() {
    logger, err := logbull.NewLogger(logbull.Config{
        Host:      "http://LOGBULL_HOST",
        ProjectID: "LOGBULL_PROJECT_ID",
        APIKey:    "YOUR_API_KEY", // optional
        LogLevel:  logbull.INFO,
    })
    if err != nil {
        panic(err)
    }
    defer logger.Shutdown()

    logger.Info("User logged in successfully", map[string]any{
        "user_id":  "12345",
        "username": "john_doe",
        "ip":       "192.168.1.100",
    })

    // We need to wait a bit in short-living programs when logs
    // received by Log Bull. This is not needed in production
    logger.Flush()
    time.Sleep(3 * time.Second)
}
```

## Usage examples

### 1. Standalone LogBullLogger

```go
package main

import (
    "time"

    "github.com/logbull/logbull-go/logbull"
)

func main() {
    logger, err := logbull.NewLogger(logbull.Config{
        Host:      "http://LOGBULL_HOST",
        ProjectID: "LOGBULL_PROJECT_ID",
        APIKey:    "YOUR_API_KEY", // optional
        LogLevel:  logbull.INFO,
    })
    if err != nil {
        panic(err)
    }
    defer logger.Shutdown()

    logger.Info("Application started", nil)

    logger.Info("User logged in successfully", map[string]any{
        "user_id":  "12345",
        "username": "john_doe",
        "ip":       "192.168.1.100",
    })

    sessionLogger := logger.WithContext(map[string]any{
        "session_id": "sess_abc123",
        "user_id":    "user_456",
    })

    sessionLogger.Info("Processing user request", map[string]any{
        "action": "purchase",
        "amount": 99.99,
    })

    logger.Error("Database connection failed", map[string]any{
        "database":   "users_db",
        "error_code": 500,
    })

    // We need to wait a bit in short-living programs when logs
    // received by Log Bull. This is not needed in production
    logger.Flush()
    time.Sleep(3 * time.Second)
}
```

#### Context management

```go
// Attach persistent context to all subsequent logs
sessionLogger := logger.WithContext(map[string]any{
    "session_id": "sess_abc123",
    "user_id":    "user_456",
    "request_id": "req_789",
})

// All logs from sessionLogger include the context automatically
sessionLogger.Info("User started checkout process", map[string]any{
    "cart_items":   3,
    "total_amount": 149.99,
})
// Output includes: session_id, user_id, request_id + cart_items, total_amount

sessionLogger.Error("Payment processing failed", map[string]any{
    "payment_method": "credit_card",
    "error_code":     "DECLINED",
})

// Context can be chained
transactionLogger := sessionLogger.WithContext(map[string]any{
    "transaction_id": "txn_xyz789",
    "merchant_id":    "merchant_123",
})

transactionLogger.Info("Transaction completed", map[string]any{
    "amount":   149.99,
    "currency": "USD",
})
// Includes all previous context + new transaction context

// We need to wait a bit in short-living programs when logs
// reach Log Bull. This is not needed in production
logger.Flush()
time.Sleep(3 * time.Second)
```

### 2. Standard library slog integration

```go
package main

import (
    "log/slog"
    "time"

    "github.com/logbull/logbull-go/logbull"
)

func main() {
    handler, err := logbull.NewSlogHandler(logbull.Config{
        Host:      "http://LOGBULL_HOST",
        ProjectID: "LOGBULL_PROJECT_ID",
        APIKey:    "YOUR_API_KEY",
    })
    if err != nil {
        panic(err)
    }
    defer handler.Shutdown()

    logger := slog.New(handler)

    logger.Info("User action",
        slog.String("user_id", "12345"),
        slog.Int("action_id", 42),
    )

    logger.Info("Request processed",
        slog.Group("request",
            slog.String("method", "POST"),
            slog.String("path", "/api/users"),
            slog.Int("status", 201),
        ),
    )

    // We need to wait a bit in short-living programs when logs
    // received by Log Bull. This is not needed in production
    handler.Flush()
    time.Sleep(3 * time.Second)
}
```

### 3. Uber-go zap integration

```go
package main

import (
    "time"

    "go.uber.org/zap"

    "github.com/logbull/logbull-go/logbull"
)

func main() {
    core, err := logbull.NewZapCore(logbull.Config{
        Host:      "http://LOGBULL_HOST",
        ProjectID: "LOGBULL_PROJECT_ID",
        APIKey:    "YOUR_API_KEY",
        LogLevel:  logbull.INFO,
    })
    if err != nil {
        panic(err)
    }
    defer core.Shutdown()

    logger := zap.New(core)

    logger.Info("User action",
        zap.String("user_id", "12345"),
        zap.Int("action_id", 42),
    )

    logger.Error("Processing failed",
        zap.String("component", "payment"),
        zap.String("error", "connection timeout"),
    )

    // We need to wait a bit in short-living programs when logs
    // received by Log Bull. This is not needed in production
    logger.Sync()
    time.Sleep(3 * time.Second)
}
```

### 4. Sirupsen Logrus integration

```go
package main

import (
    "time"

    "github.com/sirupsen/logrus"

    "github.com/logbull/logbull-go/logbull"
)

func main() {
    hook, err := logbull.NewLogrusHook(logbull.Config{
        Host:      "http://LOGBULL_HOST",
        ProjectID: "LOGBULL_PROJECT_ID",
        APIKey:    "YOUR_API_KEY",
        LogLevel:  logbull.INFO,
    })
    if err != nil {
        panic(err)
    }
    defer hook.Shutdown()

    logrus.AddHook(hook)

    logrus.WithFields(logrus.Fields{
        "user_id": "12345",
        "action":  "login",
    }).Info("User action")

    logrus.WithFields(logrus.Fields{
        "order_id": "ord_123",
        "amount":   99.99,
    }).Error("Payment failed")

    // We need to wait a bit in short-living programs when logs
    // received by Log Bull. This is not needed in production
    hook.Flush()
    time.Sleep(3 * time.Second)
}
```

## Configuration options

### Config parameters

- `ProjectID` (required): Your LogBull project ID (UUID format)
- `Host` (required): LogBull server URL (e.g., `http://localhost:4005`)
- `APIKey` (optional): API key for authentication
- `LogLevel` (optional): Minimum log level to process (default: `INFO`)

### Available log levels

- `DEBUG`: Detailed information for debugging
- `INFO`: General information messages
- `WARNING`: Warning messages
- `ERROR`: Error messages
- `CRITICAL`: Critical error messages

## Features

- **Multiple integration options**: Standalone logger, `slog` handler, `zap` core, and `logrus` hook
- **Context support**: Attach persistent context to logs (session_id, user_id, etc.)
- **Thread-safe**: All operations are safe for concurrent use
